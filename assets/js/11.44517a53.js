(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{328:function(s,n,a){"use strict";a.r(n);var t=a(0),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"从全排列看回溯算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从全排列看回溯算法"}},[s._v("#")]),s._v(" 从全排列看回溯算法")]),s._v(" "),a("p",[s._v("最近又刷起了算法，仿佛回到了大一时奋战到深夜场景，走上社会之初发现大学里学的都是啥玩意儿，工作中基本遇不到，各种数据结构都被封装的妥妥的根本不需要我们去操心，以至于越来越浮于表面。")]),s._v(" "),a("p",[s._v("现在觉得大学的课程是真功夫，是无数学者总结提炼的精华，是计算机从业人员是基本功，基本功不扎实很快就会遇到瓶颈，对算法与数据结构掌握与理解不透彻很难写出非常优秀的软件，亡羊补牢为时不晚，所以拿起旧书本回炉重造磨练自己基本功。 学习算法不仅会收获很多还会给你带来成就感。")]),s._v(" "),a("p",[s._v("下面用通俗的方式结合例子给大家介绍回溯算法")]),s._v(" "),a("h1",{attrs:{id:"回溯算法框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法框架"}},[s._v("#")]),s._v(" 回溯算法框架")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("func backtrack(选择列表,路径) {\n   if 结束条件 {\n       得到一种结果\n   }\n   for i in 选择列表 {\n      if 减支条件 {\n         continue\n      }\n      选择列表加入路径\n      backtrack(选择列表,路径)\n      撤销选择\n   }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("这个先看不太懂没关系，读完全文可再返回阅读。 回溯算法本质就是一个多叉树遍历问题")]),s._v(" "),a("p",[s._v("我们以在袋子里抓球为力来解释一下上面几个名词。 假设袋子里三个球，抓一个那么就有三种选择，所以选择列表是：[1,2,3] , 如果你抓到1，那么[1]便是路径，对应的是树的树枝。")]),s._v(" "),a("p",[s._v("结束条件：比如你只抓一次，那么结束条件就是路径长度等于1\n减支条件：比如抓完放回球，那么就没有减支条件，如果抓完不放回那么条件就是路径里如果已经存在就不再遍历。 很多时候不同的问题都是在减支条件这里做手脚，比如N皇后问题.\n撤销选择：为啥要撤销选择？其实就是在遍历到叶子节点之后我们需要重新返回到父节点重新寻找其它路径")]),s._v(" "),a("h1",{attrs:{id:"全排列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全排列"}},[s._v("#")]),s._v(" 全排列")]),s._v(" "),a("p",[s._v("给定一个不幸串，输出它的全排列")]),s._v(" "),a("p",[s._v("先来看个最简单的场景：")]),s._v(" "),a("p",[s._v("袋子里有两个球，取出一个记下，放回袋子，再取一个，有多少种结果")]),s._v(" "),a("p",[s._v("输入：[1,2]\n输出：[[1,1],[1,2],[2,1],[2,2]]")]),s._v(" "),a("p",[s._v("这样就得出一个二叉树：")]),s._v(" "),a("p",[a("a",{attrs:{href:""}},[s._v("图")])]),s._v(" "),a("p",[s._v("所有到叶子节点的路径就是我们需要求解的解集，所以这个问题变成了一个多叉树遍历问题：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("func tree(选择,路径){\n   结束条件\n   遍历分叉\n     进入节点前干啥\n     递归节点\n     遍历节点后干啥\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("所谓回溯，就是在遍历节点后撤销我们选择路径中的选择，所以想一下第一次遍历：\n"),a("a",{attrs:{href:""}},[s._v("图三")]),s._v("\n已经走到了一个叶子节点，这时我们已经得出一个解[1,1]并且已经把它存在res的结果中。")]),s._v(" "),a("p",[s._v("所以我们现在想从叶子节点A走回到B，下一步往C去走。这样在回溯到B之前路径是[1,1],回溯之后路径变成[1], 然后递归遍历到C时路径变成[1,2]得到第二个解")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("res [][]int\nfunc tree(nums []int, track []int) {\n   if len(track) == 2 //我们取两次 {\n       // 取到了一个结果\n       res = append(res,track)\n   }\n   for _,n := range nums {\n      // 遍历选择列表，把选择列表加入到路径中，所以选择列表多长就是多少叉树\n      track = append(track, n)\n      tree(nums, track)\n      track = track[:len(track) - 1] // 撤销路径最后一个选择,在此之前已经遍历到叶子节点并把解记录到了res中，因为递归时已经满足了结束条件\n   }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("有了回溯法，寥寥几行代码就解决了上面问题。下面来加大一下难度：")]),s._v(" "),a("blockquote",[a("p",[s._v("全排列")])]),s._v(" "),a("p",[s._v("一串不重复的数字，输出其全排列，如：")]),s._v(" "),a("p",[s._v("输入：[1,2]\n输出：[[1,2],[2,1]]")]),s._v(" "),a("p",[s._v("一眼就能看到结果是上面题目的子集，说明啥？多叉树被剪枝了！ 如何剪枝?")]),s._v(" "),a("p",[s._v("很简单，满足一定条件啥也不做就行，不去选择->递归->撤销选择, 所以：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("func tree(选择,路径){\n   结束条件\n   遍历分叉\n     if 满足剪枝条件\n        continue\n     进入节点前干啥\n     递归节点\n     遍历节点后干啥\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("问题就简化为剪枝条件是啥？")]),s._v(" "),a("p",[s._v("显然特点就是已经出现在路径中的元素就不能再选择：")]),s._v(" "),a("p",[a("a",{attrs:{href:""}},[s._v("图二")])]),s._v(" "),a("p",[s._v("代码其它部分不变，for循环里变成：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("for _,n := range nums {\n   if has(track,n) { //表示track列表中包含n\n      continue\n   }\n   track = append(track, n)\n   tree(nums, track)\n   track = track[:len(track) - 1] // 撤销路径最后一个选择,在此之前已经遍历到叶子节点并把解记录到了res中，因为递归时已经满足了结束条件\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("轻松搞定")]),s._v(" "),a("blockquote",[a("p",[s._v("有重复元素的全排列")])]),s._v(" "),a("p",[s._v("现在假设选择列表nums中有重复元素如[1,1,2,3]那又该怎么做？")]),s._v(" "),a("p",[s._v("聪明人立马会意识到，其它不变，只是剪枝条件发生了变化：")]),s._v(" "),a("ol",[a("li",[s._v("选择列表中的元素没有被遍历过")]),s._v(" "),a("li",[s._v("任何节点的树枝不能重复")])]),s._v(" "),a("p",[s._v("要注意不能被重复剪枝，在判断是不是重复时不用考虑已经被剪枝的树枝")]),s._v(" "),a("p",[s._v("[图四]")]),s._v(" "),a("p",[s._v("所以最主要的是修改剪枝条件，但是判断某个元素是否被访问过我们需要引入一个数组来保存选择列表某个元素是否被访问")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\t\tif flag[i] {\n\t\t\tcontinue\n\t\t}\n\t\tif Has(num[:i], num[i], flag) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttrack = append(track, num[i])\n\t\tflag[i] = true\n\t\tback(num, flag, track)\n\t\ttrack = track[:len(track)-1]\n\t\tflag[i] = false\n\nfunc Has(a []int, b int, flag []bool) bool {\n\tl := len(a)\n\tif l == 0 {\n\t\treturn false\n\t}\n\tfor i := 0; i < l; i++ {\n\t\tif flag[i] {        // 细节，不用考虑已经被剪枝的树枝\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] == b {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br")])]),a("p",[s._v("至此你已经掌握了回溯算法的精髓，然后就是活学活用推广到其它问题中。一定要动手再细细琢磨才能触类旁通。")]),s._v(" "),a("blockquote",[a("p",[s._v("N皇后问题")])]),s._v(" "),a("p",[s._v("在一个N*N的棋盘上摆N个皇后，彼此不攻击对方的摆法。")]),s._v(" "),a("p",[s._v("有了回溯算法的基础此问题就变得简单了。")]),s._v(" "),a("p",[s._v("一行一行的放皇后，第一行就有N种放法，如此就又变成了一颗N叉树，思考三个核心元素： 选择列表是啥，路径是啥，剪枝条件是啥")]),s._v(" "),a("ol",[a("li",[s._v("选择列表就可以用一个N位数组")]),s._v(" "),a("li",[s._v("路径可以用二维数组")]),s._v(" "),a("li",[s._v("剪枝条件就变成放的位置横竖斜有没有皇后")])]),s._v(" "),a("p",[s._v("如此问题便可解决，如果建议学完回溯算法再拿N皇后稳定巩固一下。")])])}),[],!1,null,null,null);n.default=e.exports}}]);